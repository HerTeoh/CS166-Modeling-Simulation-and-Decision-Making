import random
import numpy as np
from matplotlib import colors
import matplotlib.pyplot as plt
from tqdm import tqdm

class roomba_vroomba(object):
    
    def __init__(self, width, depth):
        '''
        Initilisation of the size of the room, the current position of the roomba,
        and the battery life remaining.
        '''
        # input for number of rows
        self.depth = depth
        
        # input for number of columns
        self.width = width
        
        # numpy array of zeroes for the size of the room
        self.floor_plan = np.zeros((self.depth, self.width))
        
        # presets the roomba to the top left corner of the room
        self.current_position_x = random.randint(0,self.depth-1)
        self.current_position_y = random.randint(0,self.width-1)
        
        # presets a battery life of 100 steps
        self.remaining_battery_life = 1000
        
        # for measurement purposes the full battery life is stored
        self.full_battery_life = 1000
    
    def visualise(self):
        '''
        Sets the Roomba machine to be distinct from the floor and prints out a 
        bird's eye view of the room.
        
        Blue: Roomba machine
        Black: Obstacle
        Dark Brown: Dirty floor
        Medium Brown: Less dirty floor
        Light Brown: Almost clean floor
        White: Clean floor
        '''
        # creates a copy of the floor plan
        temp = np.copy(self.floor_plan)
        
        # identifies the roomba and makes it distinct
        temp[self.current_position_x, self.current_position_y] = 5
        
        # prints the remaining battery life
        print "%r battery life remaining" % self.remaining_battery_life
                
        # the colour map for the different degrees of cleanliness, obstacles,
        # and the Roomba
        cmap = colors.ListedColormap(['sienna','darksalmon','mistyrose','white',
                                      'black','dodgerblue'])
        bounds = [0,1,2,3,4,5]
        plt.imshow(temp, interpolation='nearest', cmap = cmap, vmin=0, vmax=5)
        plt.title('Bird\'s eye view of the floor')
        plt.tight_layout()
        plt.show()
        
    def obstacle_input(self, obstacles):
        '''
        Allows the addition of obstacles onto the floor plan that the Roomba
        will not tread over.
        '''
        # assigns each obstacles onto the floor plan by assigning it a value of 4
        for i in obstacles:
            self.floor_plan[i[0], i[1]] = 4
    def walk(self):
        '''
        A random walk algorithm that examines which tiles around the Roomba it can go
        to next and picks one regardless of cleanliness to Roomba over.
        '''
        # since this is not a periodic boundary condition, candidates for the next
        # step are determined here
        candidates = []
        if 0 <= self.current_position_x+1 <= self.depth-1 and self.floor_plan[self.current_position_x+1, self.current_position_y] < 4:
            candidates.append([self.current_position_x+1, self.current_position_y])
        if 0 <= self.current_position_x-1 <= self.depth-1 and self.floor_plan[self.current_position_x-1, self.current_position_y] < 4:
            candidates.append([self.current_position_x-1, self.current_position_y])
        if 0 <= self.current_position_y+1 <= self.depth-1 and self.floor_plan[self.current_position_x, self.current_position_y+1] < 4:
            candidates.append([self.current_position_x, self.current_position_y+1])
        if 0 <= self.current_position_y-1 <= self.depth-1 and self.floor_plan[self.current_position_x, self.current_position_y-1] < 4:
            candidates.append([self.current_position_x, self.current_position_y-1])
        
        # the next position is a random choice of the candidates
        next_position = random.choice(candidates)

        # updates the cleanliness of the floor
        if self.floor_plan[self.current_position_x, self.current_position_y] < 3:
            self.floor_plan[self.current_position_x, self.current_position_y] += 1
        
        # updates the new position and the battery life
        self.current_position_x = next_position[0]
        self.current_position_y = next_position[1]
        self.remaining_battery_life -= 1
    
    def take_a_walk(self, steps, images):
        '''
        Using the number of steps and images requested, uses the random walk
        algorithm until the battery runs out, the floor has been Roomba'ed at least
        3 times, or the number of steps has been achieved.
        '''
        for i in range(images):
            for j in range(steps/images):
                
                # checks if the Roomba still has charge left in the battery
                if self.remaining_battery_life == 0:
                    print'Battery Life at 0, please charge me.'
                    self.visualise()
                    return self.full_battery_life
                
                # checks if the room has been Roomba'ed at least 3 times over
                if (self.floor_plan >= 3).all():
                    print "The room is clean!"
                    self.visualise()
                    return self.full_battery_life - self.remaining_battery_life
                
                # otherwise, continue updating the steps using the center spiral
                # algorithm
                self.walk()
